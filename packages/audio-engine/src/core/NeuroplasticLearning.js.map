{"version":3,"file":"NeuroplasticLearning.js","sourceRoot":"","sources":["NeuroplasticLearning.ts"],"names":[],"mappings":"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","sourcesContent":["import * as tf from '@tensorflow/tfjs';\nimport { EventEmitter } from 'events';\n\ninterface LearningPattern {\n  bpm: number;\n  key: string;\n  scale: string;\n  timbreProfile: number[];\n  rhythmPattern: number[];\n  timestamp: number;\n}\n\n/**\n * NeuroplasticLearning - AI system that adapts to producer's style through neuroplasticity principles\n */\nexport class NeuroplasticLearning extends EventEmitter {\n  private model: tf.LayersModel | null = null;\n  private learningRate = 0.01;\n  private memoryWindow = 100; // Number of patterns to remember\n  private memory: LearningPattern[] = [];\n  private isTraining = false;\n\n  constructor() {\n    super();\n    this.initializeModel();\n  }\n\n  private async initializeModel() {\n    // Create a simple neural network for pattern recognition\n    this.model = tf.sequential({\n      layers: [\n        tf.layers.dense({ \n          inputShape: [10], // Input features\n          units: 32,\n          activation: 'relu',\n          kernelInitializer: 'heNormal'\n        }),\n        tf.layers.dropout({ rate: 0.2 }),\n        tf.layers.dense({ \n          units: 16, \n          activation: 'relu' \n        }),\n        tf.layers.dense({ \n          units: 8, // Output features (style vector)\n          activation: 'tanh' \n        })\n      ]\n    });\n\n    // Compile the model\n    this.model.compile({\n      optimizer: tf.train.adam(this.learningRate),\n      loss: 'meanSquaredError',\n      metrics: ['accuracy']\n    });\n\n    this.emit('modelInitialized');\n  }\n\n  /**\n   * Add a new pattern to the learning memory\n   */\n  public addPattern(pattern: Omit<LearningPattern, 'timestamp'>) {\n    const timestampedPattern = {\n      ...pattern,\n      timestamp: Date.now()\n    };\n\n    // Add to memory\n    this.memory.push(timestampedPattern);\n    \n    // Keep memory within window\n    if (this.memory.length > this.memoryWindow) {\n      this.memory.shift();\n    }\n\n    // Trigger learning if we have enough data\n    if (this.memory.length > 10 && !this.isTraining) {\n      this.trainModel();\n    }\n  }\n\n  /**\n   * Train the model on the current memory\n   */\n  private async trainModel() {\n    if (this.memory.length < 10 || !this.model) return;\n    \n    this.isTraining = true;\n    this.emit('trainingStart');\n\n    try {\n      // Prepare training data\n      const xs: number[][] = [];\n      const ys: number[][] = [];\n\n      for (const pattern of this.memory) {\n        // Extract features (simplified example)\n        const x = [\n          pattern.bpm / 200, // Normalize bpm (assuming max 200 bpm)\n          ...pattern.timbreProfile.slice(0, 5), // First 5 timbre features\n          ...pattern.rhythmPattern.slice(0, 4)  // First 4 rhythm features\n        ];\n        \n        // Target is the same as input (autoencoder-style)\n        xs.push(x);\n        ys.push(x);\n      }\n\n      // Convert to tensors\n      const xTensor = tf.tensor2d(xs);\n      const yTensor = tf.tensor2d(ys);\n\n      // Train the model\n      await this.model.fit(xTensor, yTensor, {\n        epochs: 20,\n        batchSize: 16,\n        callbacks: {\n          onEpochEnd: (epoch, logs) => {\n            this.emit('trainingProgress', { epoch, ...logs });\n          }\n        }\n      });\n\n      this.emit('trainingComplete');\n    } catch (error) {\n      console.error('Error during training:', error);\n      this.emit('trainingError', error);\n    } finally {\n      this.isTraining = false;\n    }\n  }\n\n  /**\n   * Predict the next pattern based on current style\n   */\n  public async predictNextPattern(currentPattern: Omit<LearningPattern, 'timestamp'>) {\n    if (!this.model) return null;\n\n    try {\n      // Prepare input\n      const input = tf.tensor2d([\n        [\n          currentPattern.bpm / 200,\n          ...currentPattern.timbreProfile.slice(0, 5),\n          ...currentPattern.rhythmPattern.slice(0, 4)\n        ]\n      ]);\n\n      // Get prediction\n      const prediction = this.model.predict(input) as tf.Tensor;\n      const values = await prediction.array() as number[][];\n      \n      // Convert prediction back to pattern (simplified)\n      return {\n        bpm: values[0][0] * 200, // Denormalize bpm\n        key: currentPattern.key, // Would need key detection logic\n        scale: currentPattern.scale, // Would need scale detection logic\n        timbreProfile: values[0].slice(1, 6),\n        rhythmPattern: values[0].slice(6, 10)\n      };\n    } catch (error) {\n      console.error('Prediction error:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Get the current style vector\n   */\n  public async getStyleVector() {\n    if (!this.model || this.memory.length === 0) return null;\n\n    try {\n      // Use the encoder part of the model to get style vector\n      const encoder = tf.model({\n        inputs: this.model.inputs,\n        outputs: this.model.layers[this.model.layers.length - 1].output\n      });\n\n      const pattern = this.memory[this.memory.length - 1];\n      const input = tf.tensor2d([\n        [\n          pattern.bpm / 200,\n          ...pattern.timbreProfile.slice(0, 5),\n          ...pattern.rhythmPattern.slice(0, 4)\n        ]\n      ]);\n\n      const styleVector = encoder.predict(input) as tf.Tensor;\n      return await styleVector.array();\n    } catch (error) {\n      console.error('Error getting style vector:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Reset the learning model\n   */\n  public reset() {\n    this.memory = [];\n    this.initializeModel();\n    this.emit('modelReset');\n  }\n}\n\nexport default NeuroplasticLearning;\n"]}