{"version":3,"file":"NeuroplasticLearning.test.js","sourceRoot":"","sources":["NeuroplasticLearning.test.ts"],"names":[],"mappings":"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","sourcesContent":["import { NeuroplasticLearning } from '../NeuroplasticLearning';\nimport * as tf from '@tensorflow/tfjs';\n\n// Mock TensorFlow.js\njest.mock('@tensorflow/tfjs', () => ({\n  sequential: jest.fn(),\n  train: {\n    adam: jest.fn(() => 'adam-optimizer')\n  },\n  layers: {\n    dense: jest.fn(),\n    dropout: jest.fn()\n  },\n  tensor2d: jest.fn(),\n  model: jest.fn()\n}));\n\ndescribe('NeuroplasticLearning', () => {\n  let learning: NeuroplasticLearning;\n  \n  beforeEach(() => {\n    // Reset all mocks\n    jest.clearAllMocks();\n    \n    // Setup mock model\n    const mockFit = jest.fn().mockResolvedValue({});\n    const mockPredict = jest.fn().mockReturnValue(tf.tensor2d([[0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8]]));\n    \n    (tf.sequential as jest.Mock).mockReturnValue({\n      add: jest.fn(),\n      compile: jest.fn(),\n      fit: mockFit,\n      predict: mockPredict,\n      layers: [\n        { output: 'mock-output' },\n        { output: 'mock-output' },\n        { output: 'mock-output' }\n      ],\n      inputs: ['mock-input']\n    });\n    \n    (tf.model as jest.Mock).mockReturnValue({\n      predict: mockPredict\n    });\n    \n    learning = new NeuroplasticLearning();\n  });\n  \n  describe('initialization', () => {\n    it('should initialize with default values', () => {\n      expect(learning).toBeInstanceOf(NeuroplasticLearning);\n      expect(tf.sequential).toHaveBeenCalled();\n    });\n  });\n  \n  describe('addPattern', () => {\n    it('should add a pattern to memory', () => {\n      const pattern = {\n        bpm: 120,\n        key: 'C',\n        scale: 'major',\n        timbreProfile: [0.1, 0.2, 0.3, 0.4, 0.5],\n        rhythmPattern: [1, 0, 1, 0]\n      };\n      \n      learning.addPattern(pattern);\n      \n      // Check if the pattern was added with a timestamp\n      const memory = (learning as any).memory;\n      expect(memory).toHaveLength(1);\n      expect(memory[0]).toMatchObject(pattern);\n      expect(memory[0].timestamp).toBeDefined();\n    });\n    \n    it('should maintain memory window size', () => {\n      const pattern = {\n        bpm: 120,\n        key: 'C',\n        scale: 'major',\n        timbreProfile: [0.1, 0.2, 0.3, 0.4, 0.5],\n        rhythmPattern: [1, 0, 1, 0]\n      };\n      \n      // Add more patterns than the memory window\n      for (let i = 0; i < 150; i++) {\n        learning.addPattern({\n          ...pattern,\n          bpm: 120 + i\n        });\n      }\n      \n      const memory = (learning as any).memory;\n      expect(memory).toHaveLength(100); // Default window size\n      expect(memory[0].bpm).toBe(170); // First item should be the 51st pattern (120 + 50)\n      expect(memory[99].bpm).toBe(269); // Last item should be the 150th pattern\n    });\n  });\n  \n  describe('training', () => {\n    it('should start training when enough patterns are added', async () => {\n      const mockFit = jest.fn().mockResolvedValue({});\n      (tf.sequential as jest.Mock).mockReturnValueOnce({\n        add: jest.fn(),\n        compile: jest.fn(),\n        fit: mockFit,\n        predict: jest.fn().mockReturnValue(tf.tensor2d([[0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8]])),\n        layers: [\n          { output: 'mock-output' },\n          { output: 'mock-output' },\n          { output: 'mock-output' }\n        ],\n        inputs: ['mock-input']\n      });\n      \n      learning = new NeuroplasticLearning();\n      \n      // Add enough patterns to trigger training\n      for (let i = 0; i < 15; i++) {\n        learning.addPattern({\n          bpm: 120 + i,\n          key: 'C',\n          scale: 'major',\n          timbreProfile: [0.1, 0.2, 0.3, 0.4, 0.5],\n          rhythmPattern: [1, 0, 1, 0]\n        });\n      }\n      \n      // Wait for training to complete\n      await new Promise(resolve => setTimeout(resolve, 100));\n      \n      // Check if training was called\n      expect(mockFit).toHaveBeenCalled();\n    });\n  });\n  \n  describe('prediction', () => {\n    it('should predict next pattern', async () => {\n      const prediction = await learning.predictNextPattern({\n        bpm: 120,\n        key: 'C',\n        scale: 'major',\n        timbreProfile: [0.1, 0.2, 0.3, 0.4, 0.5],\n        rhythmPattern: [1, 0, 1, 0]\n      });\n      \n      expect(prediction).toBeDefined();\n      expect(prediction?.bpm).toBeCloseTo(20); // 0.1 * 200 (denormalized)\n    });\n  });\n  \n  describe('style vector', () => {\n    it('should get style vector', async () => {\n      // Add a pattern first\n      learning.addPattern({\n        bpm: 120,\n        key: 'C',\n        scale: 'major',\n        timbreProfile: [0.1, 0.2, 0.3, 0.4, 0.5],\n        rhythmPattern: [1, 0, 1, 0]\n      });\n      \n      const styleVector = await learning.getStyleVector();\n      expect(styleVector).toBeDefined();\n      expect(styleVector).toHaveLength(8); // 8-dimensional vector from mock\n    });\n  });\n  \n  describe('reset', () => {\n    it('should reset the model and memory', () => {\n      // Add some patterns\n      learning.addPattern({\n        bpm: 120,\n        key: 'C',\n        scale: 'major',\n        timbreProfile: [0.1, 0.2, 0.3, 0.4, 0.5],\n        rhythmPattern: [1, 0, 1, 0]\n      });\n      \n      // Reset\n      learning.reset();\n      \n      // Check if memory is cleared\n      const memory = (learning as any).memory;\n      expect(memory).toHaveLength(0);\n      \n      // Check if model was reinitialized\n      expect(tf.sequential).toHaveBeenCalledTimes(2); // Once in constructor, once in reset\n    });\n  });\n});\n"]}