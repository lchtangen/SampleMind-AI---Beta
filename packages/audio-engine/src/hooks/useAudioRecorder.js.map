{"version":3,"file":"useAudioRecorder.js","sourceRoot":"","sources":["useAudioRecorder.ts"],"names":[],"mappings":"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","sourcesContent":["import { useState, useRef, useCallback, useEffect } from 'react';\n\n// Type for the hook's return value\ninterface UseAudioRecorderReturn {\n  isRecording: boolean;\n  audioBlob: Blob | null;\n  audioUrl: string | null;\n  error: string | null;\n  audioData: Uint8Array;\n  startRecording: () => Promise<void>;\n  stopRecording: () => Promise<Blob>;\n}\n\n// Extend the Window interface to include webkit prefixed APIs\ndeclare global {\n  interface Window {\n    webkitAudioContext: new (contextOptions?: AudioContextOptions) => AudioContext;\n    webkitMediaRecorder: typeof MediaRecorder;\n  }\n}\n\n// Declare types for the Web Audio API\ndeclare const AudioContext: {\n  new (contextOptions?: AudioContextOptions): AudioContext;\n  prototype: AudioContext;\n};\n\ndeclare const MediaRecorder: {\n  new (stream: MediaStream, options?: MediaRecorderOptions): MediaRecorder;\n  isTypeSupported(type: string): boolean;\n};\n\ninterface AudioContext extends BaseAudioContext {\n  createMediaStreamSource(stream: MediaStream): MediaStreamAudioSourceNode;\n  createAnalyser(): AnalyserNode;\n  close(): Promise<void>;\n  state: AudioContextState;\n  resume(): Promise<void>;\n  suspend(): Promise<void>;\n  sampleRate: number;\n}\n\nexport const useAudioRecorder = (): UseAudioRecorderReturn => {\n  const [isRecording, setIsRecording] = useState(false);\n  const [audioBlob, setAudioBlob] = useState<Blob | null>(null);\n  const [audioUrl, setAudioUrl] = useState<string | null>(null);\n  const [error, setError] = useState<string | null>(null);\n  const [audioData, setAudioData] = useState<Uint8Array>(new Uint8Array(0));\n  \n  const mediaRecorder = useRef<MediaRecorder | null>(null);\n  const audioChunks = useRef<Blob[]>([]);\n  const audioContext = useRef<AudioContext | null>(null);\n  const analyser = useRef<AnalyserNode | null>(null);\n  const dataArray = useRef<Uint8Array>(new Uint8Array(0));\n  const bufferLengthRef = useRef(0);\n  const animationFrameId = useRef<number>(0);\n  const streamRef = useRef<MediaStream | null>(null);\n\n  const startVisualization = useCallback(() => {\n    if (!analyser.current) return;\n\n    const tick = () => {\n      if (!analyser.current) return;\n      \n      const newBufferLength = analyser.current.frequencyBinCount;\n      if (dataArray.current.length !== newBufferLength) {\n        dataArray.current = new Uint8Array(newBufferLength);\n        bufferLengthRef.current = newBufferLength;\n      }\n      \n      const tempArray = new Uint8Array(newBufferLength);\n      analyser.current.getByteFrequencyData(tempArray);\n      dataArray.current = tempArray;\n      setAudioData(new Uint8Array(tempArray));\n      \n      if (isRecording) {\n        animationFrameId.current = window.requestAnimationFrame(tick);\n      }\n    };\n\n    animationFrameId.current = window.requestAnimationFrame(tick);\n  }, [isRecording]);\n\n  const stopVisualization = () => {\n    window.cancelAnimationFrame(animationFrameId.current);\n  };\n\n  const startRecording = async () => {\n    try {\n      setError(null);\n      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n      streamRef.current = stream;\n      \n      // Set up audio context and analyser\n      const AudioCtx = window.AudioContext || window.webkitAudioContext;\n      audioContext.current = new AudioCtx();\n      analyser.current = audioContext.current.createAnalyser();\n      analyser.current.fftSize = 2048;\n      \n      const source = audioContext.current.createMediaStreamSource(stream);\n      source.connect(analyser.current);\n      \n      // Set up media recorder\n      const MediaRecorderClass = window.MediaRecorder || window.webkitMediaRecorder;\n      mediaRecorder.current = new MediaRecorderClass(stream);\n      audioChunks.current = [];\n      \n      mediaRecorder.current.ondataavailable = (event: BlobEvent) => {\n        if (event.data.size > 0) {\n          audioChunks.current.push(event.data);\n        }\n      };\n      \n      mediaRecorder.current.onstop = () => {\n        const blob = new Blob(audioChunks.current, { type: 'audio/wav' });\n        const url = URL.createObjectURL(blob);\n        setAudioBlob(blob);\n        setAudioUrl(url);\n        stopVisualization();\n      };\n      \n      mediaRecorder.current.start();\n      setIsRecording(true);\n      startVisualization();\n      \n    } catch (err) {\n      setError('Could not access microphone. Please check your permissions.');\n      console.error('Error accessing microphone:', err);\n    }\n  };\n\n  const stopRecording = useCallback(async (): Promise<Blob> => {\n    if (mediaRecorder.current && isRecording) {\n      mediaRecorder.current.stop();\n      if (mediaRecorder.current.stream) {\n        mediaRecorder.current.stream.getTracks().forEach((track: MediaStreamTrack) => track.stop());\n      }\n      setIsRecording(false);\n      return new Blob(audioChunks.current, { type: 'audio/wav' });\n    }\n    return new Blob();\n  }, [isRecording]);\n\n  useEffect(() => {\n    return () => {\n      if (mediaRecorder.current && isRecording) {\n        mediaRecorder.current.stop();\n      }\n      stopVisualization();\n    };\n  }, [isRecording]);\n\n  return {\n    isRecording,\n    audioBlob,\n    audioUrl,\n    startRecording,\n    stopRecording,\n    error,\n    audioData,\n  };\n};\n"]}