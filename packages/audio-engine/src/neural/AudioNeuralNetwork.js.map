{"version":3,"file":"AudioNeuralNetwork.js","sourceRoot":"","sources":["AudioNeuralNetwork.ts"],"names":[],"mappings":"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","sourcesContent":["import * as tf from '@tensorflow/tfjs';\nimport '@tensorflow/tfjs-backend-webgl';\n\n// Define AudioContext types for TypeScript\ndeclare global {\n  interface Window {\n    AudioContext: {\n      new (contextOptions?: AudioContextOptions): AudioContext;\n      prototype: AudioContext;\n    };\n    webkitAudioContext: {\n      new (contextOptions?: AudioContextOptions): AudioContext;\n      prototype: AudioContext;\n    };\n  }\n}\n\ninterface AudioContextOptions {\n  latencyHint?: 'balanced' | 'interactive' | 'playback';\n  sampleRate?: number;\n}\n\ntype AudioBuffer = {\n  sampleRate: number;\n  length: number;\n  duration: number;\n  numberOfChannels: number;\n  getChannelData(channel: number): Float32Array;\n  copyFromChannel(destination: Float32Array, channelNumber: number, startInChannel?: number): void;\n  copyToChannel(source: Float32Array, channelNumber: number, startInChannel?: number): void;\n};\nimport { NeurologicAudioEngine } from '../core/NeurologicAudioEngine';\n\n/**\n * AudioNeuralNetwork - Handles all neural network operations for audio analysis\n */\nexport class AudioNeuralNetwork {\n  private model: tf.LayersModel | null = null;\n  private isInitialized = false;\n  \n  // Neural network configuration\n  private readonly config = {\n    sampleRate: 44100,\n    fftSize: 2048,\n    hopLength: 512,\n    melBands: 128,\n    sequenceLength: 100,\n    modelPath: '/models/audio_analysis/model.json', // Path to pre-trained model\n  };\n\n  // Audio engine is not used in this implementation but kept for future use\n  constructor(private audioEngine?: NeurologicAudioEngine) {}\n\n  /**\n   * Initialize the neural network\n   */\n  async initialize() {\n    if (this.isInitialized) return;\n    \n    try {\n      // Load the pre-trained model\n      this.model = await tf.loadLayersModel(this.config.modelPath);\n      \n      // Warm up the model\n      const warmupInput = tf.zeros([1, this.config.sequenceLength, this.config.melBands]);\n      this.model.predict(warmupInput);\n      \n      this.isInitialized = true;\n      console.log('Neural network initialized');\n    } catch (error) {\n      console.error('Failed to initialize neural network:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Analyze audio features using the neural network\n   */\n  async analyzeAudioFeatures(audioBuffer: AudioBuffer) {\n    if (!this.isInitialized || !this.model) {\n      throw new Error('Neural network not initialized');\n    }\n\n    try {\n      // 1. Preprocess audio\n      const features = await this.extractFeatures(audioBuffer);\n      \n      // 2. Make predictions\n      const predictions = await this.model.predict(features) as tf.Tensor;\n      \n      // 3. Process predictions\n      const results = await this.processPredictions(predictions);\n      \n      return results;\n    } catch (error) {\n      console.error('Error analyzing audio:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Extract features from audio buffer\n   */\n  private async extractFeatures(audioBuffer: AudioBuffer): Promise<tf.Tensor> {\n    if (audioBuffer.numberOfChannels === 0) {\n      throw new Error('No audio channels found in the buffer');\n    }\n    // Convert audio buffer to tensor\n    const audioData = audioBuffer.getChannelData(0);\n    const audioTensor = tf.tensor1d(audioData);\n    \n    // Apply STFT (Short-Time Fourier Transform)\n    const stft = await this.computeSTFT(audioTensor);\n    \n    // Convert to Mel spectrogram\n    const melSpectrogram = await this.computeMelSpectrogram(stft);\n    \n    // Normalize\n    const normalized = tf.tidy(() => {\n      const { mean, variance } = tf.moments(melSpectrogram, [1, 2], true);\n      return melSpectrogram.sub(mean).div(tf.sqrt(variance.add(1e-8)));\n    });\n    \n    // Reshape for model input\n    return normalized.reshape([1, -1, this.config.melBands]);\n  }\n\n  /**\n   * Compute STFT of audio signal\n   */\n  private async computeSTFT(audio: tf.Tensor1D): Promise<tf.Tensor3D> {\n    const frameSize = this.config.fftSize;\n    const hopSize = this.config.hopLength;\n    const numFrames = Math.floor((audio.size - frameSize) / hopSize) + 1;\n    \n    return tf.tidy(() => {\n      // Create frames\n      const frames = (tf as any).signal.frame(audio, frameSize, hopSize);\n      \n      // Create Hann window manually since tf.hannWindow might not be available\n      const windowVals = new Float32Array(frameSize);\n      for (let i = 0; i < frameSize; i++) {\n        windowVals[i] = 0.5 * (1 - Math.cos((2 * Math.PI * i) / (frameSize - 1)));\n      }\n      const window = tf.tensor1d(windowVals);\n      \n      // Apply window function\n      const windowedFrames = frames.mul(window);\n      \n      // Compute FFT\n      const fft = (tf as any).spectral.rfft(windowedFrames);\n      \n      // Compute magnitude spectrum\n      const magnitude = tf.abs(fft as tf.Tensor);\n      \n      // Convert to power spectrum\n      const powerSpectrum = tf.square(magnitude);\n      \n      // Reshape and cast to Tensor3D\n      return tf.reshape(powerSpectrum, [1, numFrames, frameSize / 2 + 1]) as tf.Tensor3D;\n    });\n  }\n\n  /**\n   * Convert power spectrum to Mel spectrogram\n   */\n  private async computeMelSpectrogram(powerSpectrum: tf.Tensor3D): Promise<tf.Tensor3D> {\n    // Create Mel filter bank\n    const melFilterbank = this.createMelFilterbank(\n      this.config.sampleRate,\n      this.config.fftSize,\n      this.config.melBands\n    );\n    \n    return tf.tidy(() => {\n      // Apply Mel filter bank\n      const melSpectrum = tf.matMul(powerSpectrum, melFilterbank);\n      \n      // Convert to decibels\n      const logOffset = tf.scalar(1e-6);\n      const logSpectrum = tf.log(tf.add(melSpectrum, logOffset));\n      \n      return logSpectrum as tf.Tensor3D;\n    });\n  }\n\n  /**\n   * Create Mel filter bank\n   */\n  private createMelFilterbank(\n    sampleRate: number,\n    fftSize: number,\n    numBands: number\n  ): tf.Tensor2D {\n    // Implementation of Mel filter bank\n    // This is a simplified version - in a real app, you'd want a more robust implementation\n    \n    const nyquist = sampleRate / 2;\n    const melMin = this.hzToMel(0);\n    const melMax = this.hzToMel(nyquist);\n    \n    // Create Mel-spaced frequencies\n    const melPoints = tf.linspace(melMin, melMax, numBands + 2);\n    const melPointsData = melPoints.dataSync();\n    const hzPointsData = Array.from({ length: numBands + 2 }, (_, i) => \n      this.melToHz(melPointsData[i])\n    );\n    const hzPoints = tf.tensor1d(hzPointsData);\n    \n    // Convert to FFT bins\n    const bin = tf.add(hzPoints.mul(fftSize / sampleRate), 0.5).floor().toInt();\n    const binData = bin.dataSync();\n    \n    // Create filter bank\n    const filterbank = tf.buffer([numBands, fftSize / 2 + 1]);\n    \n    for (let i = 0; i < numBands; i++) {\n      const left = Math.floor(binData[i]);\n      const center = Math.floor(binData[i + 1]);\n      const right = Math.floor(binData[i + 2]);\n      \n      // Create triangular filter\n      for (let j = left; j < center; j++) {\n        if (j >= 0 && j < fftSize / 2 + 1) {\n          filterbank.set(\n            (j - left) / (center - left),\n            i, j\n          );\n        }\n      }\n      \n      for (let j = center; j < right; j++) {\n        if (j >= 0 && j < fftSize / 2 + 1) {\n          filterbank.set(\n            (right - j) / (right - center),\n            i, j\n          );\n        }\n      }\n    }\n    \n    return filterbank.toTensor().as2D(numBands, fftSize / 2 + 1);\n  }\n\n  /**\n   * Convert Hz to Mel\n   */\n  private hzToMel(hz: number): number {\n    return 2595 * Math.log10(1 + hz / 700);\n  }\n\n  /**\n   * Convert Mel to Hz\n   */\n  private melToHz(mel: number): number {\n    return 700 * (Math.pow(10, mel / 2595) - 1);\n  }\n\n  /**\n   * Process model predictions\n   */\n  private async processPredictions(predictions: tf.Tensor): Promise<AudioAnalysisResult> {\n    // In a real app, you would process the raw predictions into a more usable format\n    // This is a simplified example\n    \n    const data = await predictions.data() as Float32Array;\n    \n    return {\n      bpm: this.safeGet(data, 0, 120),\n      key: this.safeGet(data, 1, 0),\n      scale: this.safeGet(data, 2, 0),\n      energy: this.safeGet(data, 3, 0.5),\n      danceability: this.safeGet(data, 4, 0.5),\n      valence: this.safeGet(data, 5, 0.5),\n      arousal: this.safeGet(data, 6, 0.5),\n      // Add more features as needed\n    };\n  }\n\n  /**\n   * Safely get a value from the predictions array\n   */\n  private safeGet(array: Float32Array, index: number, defaultValue: number): number {\n    return index < array.length ? array[index] : defaultValue;\n  }\n\n  /**\n   * Clean up resources\n   */\n  dispose() {\n    if (this.model) {\n      this.model.dispose();\n      this.model = null;\n    }\n    this.isInitialized = false;\n  }\n}\n\n/**\n * Audio analysis result\n */\nexport interface AudioAnalysisResult {\n  bpm: number;\n  key: number;\n  scale: number;\n  energy: number;\n  danceability: number;\n  valence: number;\n  arousal: number;\n  // Add more features as needed\n}\n"]}